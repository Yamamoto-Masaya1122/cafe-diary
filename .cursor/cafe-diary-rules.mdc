---
description: "cafe-diary - カフェ日記システムの開発ルール"
globs: ["app/**/*.tsx", "components/**/*.tsx", "hooks/**/*.ts", "services/**/*.ts", "types/**/*.ts", "validations/**/*.ts", "utils/**/*.ts"]
alwaysApply: true
---

# cafe-diary - 開発ルール

## プロジェクト概要

カフェ日記システム「cafe-diary」のフロントエンドアプリケーション
- Next.js 15+ (App Router)
- TypeScript (strict mode)
- Tailwind CSS + shadcn/ui
- Atomic Design パターン

## 🧱 Atomic Design 厳守ルール

### 階層構造
- `components/1_atoms/`: Button, Input, Label など最小単位
- `components/2_molecules/`: Form, Card, SearchBox など機能単位
- `components/3_organisms/`: Header, Sidebar, DataTable など自立したセクション
- `components/ui/`: shadcn/ui コンポーネント
- `components/providers/`: Context Providers

### 必須遵守事項
1. **app/配下での直接UI記述禁止**: ページファイルには複雑なJSXを記述しない
2. **コンポーネント分離**: すべてのUIは適切な階層のコンポーネントとして実装
3. **既存コンポーネント優先**: 新規作成前に既存の拡張を検討
4. **単一責任原則**: 各コンポーネントは明確な責務を持つ

## TypeScript ルール

### 型安全性
- `any`型の使用は絶対禁止（`unknown`型を検討）
- すべての関数・変数に適切な型注釈
- Zodスキーマによるランタイム型検証必須

### 型定義パターン
```typescript
// types/example.ts
import { z } from 'zod';

export const ExampleSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  createdAt: z.string().datetime(),
});

export type Example = z.infer<typeof ExampleSchema>;
```

## API通信ルール

### サービス層パターン
```typescript
// services/exampleService.ts
import { api } from '@/lib/axios';
import { ExampleSchema, type Example } from '@/types/example';

export const exampleService = {
  async getAll(): Promise<Example[]> {
    const response = await api.get('/api/examples');
    return ExampleSchema.array().parse(response.data);
  }
};
```

### カスタムフックパターン
```typescript
// hooks/useExample.ts
export const useExample = (id: string) => {
  const [data, setData] = useState<Example | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // エラーハンドリング必須
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const result = await exampleService.getById(id);
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [id]);

  return { data, loading, error };
};
```

## スタイリングルール

### Tailwind CSS使用方針
- ユーティリティファーストアプローチ
- カスタムCSS最小化
- レスポンシブ対応（モバイルファースト）
- 既存スタイルパターンとの一貫性確保

### コンポーネントスタイリング
```typescript
export const Button = ({ variant = 'primary', size = 'md', ...props }) => {
  const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 disabled:opacity-50';
  
  const variantClasses = {
    primary: 'bg-primary text-primary-foreground hover:bg-primary/90',
    secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
  };
  
  const sizeClasses = {
    sm: 'h-9 px-3 text-xs',
    md: 'h-10 py-2 px-4 text-sm',
    lg: 'h-11 px-8 text-base',
  };
  
  return (
    <button 
      className={cn(baseClasses, variantClasses[variant], sizeClasses[size])}
      {...props}
    />
  );
};
```

## 状態管理ルール

### 基本方針
- ローカル状態: `useState`, `useReducer`
- グローバル状態: `useContext` + `useReducer`（必要な場合のみ）
- サーバー状態: カスタムフック

### Context使用パターン
```typescript
// providers/ExampleProvider.tsx
const ExampleContext = createContext<{
  state: ExampleState;
  dispatch: React.Dispatch<ExampleAction>;
} | null>(null);

export const useExample = () => {
  const context = useContext(ExampleContext);
  if (!context) {
    throw new Error('useExample must be used within ExampleProvider');
  }
  return context;
};
```

## エラーハンドリング

### 統一的なエラー処理
```typescript
// utils/error-handlers.ts
export const handleApiError = (error: unknown): string => {
  if (axios.isAxiosError(error)) {
    return error.response?.data?.message || error.message;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return '予期しないエラーが発生しました';
};
```

## パフォーマンス最適化

### 推奨事項
- 動的インポート: `React.lazy` + `Suspense`
- メモ化: `React.memo`, `useMemo`, `useCallback`の適切な使用
- 画像最適化: Next.js `Image`コンポーネント
- 不要なインポート削除

## 命名規則

- **ファイル名**: kebab-case (例: `user-profile.tsx`)
- **コンポーネント名**: PascalCase (例: `UserProfile`)
- **関数・変数名**: camelCase (例: `getUserData`)
- **定数**: UPPER_SNAKE_CASE (例: `API_BASE_URL`)
- **型名**: PascalCase (例: `UserData`)

## アクセシビリティ

### 必須対応
- キーボードナビゲーション対応
- 適切なARIA属性設定
- セマンティックHTML使用
- WCAG 2.1 AA準拠のコントラスト比

## 禁止事項

❌ **絶対禁止**
- `app/`配下での直接複雑なUI記述
- `components/`配下以外でのUIコンポーネント定義
- `any`型の使用
- `console.log`の本番環境混入
- 未使用インポート・コード
- 型定義なしAPI通信
- インラインスタイル使用

## 推奨事項

✅ **積極推奨**
- 既存コンポーネントの再利用
- 型安全性確保
- 包括的エラーハンドリング
- アクセシビリティ対応
- パフォーマンス最適化
- 可読性向上
- 適切なコメント（複雑ロジックのみ）

## 開発ワークフロー

### 新機能開発手順
1. **要件分析**: 必要コンポーネント・型を特定
2. **型定義作成**: `types/`と`validations/`にスキーマ定義
3. **コンポーネント実装**: Atom → Molecule → Organism順
4. **API統合**: サービス層とカスタムフック実装
5. **テスト**: 動作確認とエラーケース対応
6. **リファクタリング**: コード最適化

### Git運用
- **コミットメッセージ**: 日本語で明確に記述
- **ブランチ命名**: `feature/機能名`, `fix/修正内容`
- **プルリクエスト**: 小単位で頻繁作成

---

このルールに従って、保守性が高く拡張しやすいアプリケーションを構築してください。
疑問点は既存コードベースを参考に、一貫性を最優先としてください。